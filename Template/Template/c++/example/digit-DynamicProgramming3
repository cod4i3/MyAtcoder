/*
    N以下の全ての正整数について、1 は何回出現するか？
    1≤𝑁≤10^9

    1 の出現回数を求めたいので、「1 が j 回出現する数がいくつあるか」を求めることを考えます。

    dp[ i ][smaller][ j ] := i 桁目までを決めた時、 1 が j 回出現する数がいくつあるか。
                             smaller が true ならNより小さい場合を考え、
                             smallerが false ならNと同じ場合を考える。
    
    ∑(𝑗=1 ~ 9) 𝑗⋅(dp[Nの桁数][true][ j ]+dp[Nの桁数][false][ j ])
*/


ll dp[11][2][11];
 
int main() {
    string N;
    cin >> N;
    
    int n = N.size();
 
    dp[0][0][0] = 1;
 
    REP(i, n) {
        REP(j, 10) {
            // i桁目まででNより小さいならi+1桁目は何でも良い
            dp[i + 1][1][j]     += dp[i][1][j] * 9;  // i+1桁目が1以外(0, 2~9)
            dp[i + 1][1][j + 1] += dp[i][1][j];  // i+1桁目が1なので出現回数jが+1される
 
            int ni = (N[i] - '0');
 
            // i桁目までNと同じで、i+1桁目はNより小さい数の時
            if (ni > 1) {
                // ここはi桁目が2以上のゾーン。この場合1が入る可能性があるので場合分けを行う
                dp[i + 1][1][j] += dp[i][0][j] * (ni - 1);  // i+1桁目が0~ ni-1のうちの1以外
                dp[i + 1][1][j + 1] += dp[i][0][j];         // i+1桁目が1
            } else if (ni == 1) {
                // ここはi桁目が0のゾーン。 当然0より小さい数はないので場合分けは行わない。
                dp[i + 1][1][j] += dp[i][0][j];  // i+1桁目が0、出現回数は変わらない
            }
 
            //  i桁目までNと同じで、i+1桁目もNと同じ数の時
            if (ni == 1) {
                dp[i + 1][0][j + 1] = dp[i][0][j];  // i+1桁目が1
            } else {
                dp[i + 1][0][j] = dp[i][0][j];  // i+1桁目が1以外
            }
        }
    }
 
    ll ans = 0;
    REP(j, 10) { ans += (dp[n][0][j] + dp[n][1][j]) * j; }
 
    cout << ans << endl;
 
    return 0;
}