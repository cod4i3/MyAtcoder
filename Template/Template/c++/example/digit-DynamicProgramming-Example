この説明は以下の二つのサイトから引用しました
https://algo-logic.info/digit-dp/
https://drken1215.hatenablog.com/entry/2019/02/04/013700

非負整数 X が X≤K の範囲を動くときの、〜〜〜の最大値を求めよ
非負整数 X が X≤K の範囲を動くときの、〜〜〜という条件を満たすものは何通りあるか

dp[ i ] := 上から i 桁目まで決めたときの暫定スコアの最大値とか最小値とか
K = 8357のとき、このままだと
    dp[2] を最大にするXが82ならば、83より小さいので次の桁の数は何でもいい
    dp[2] を最大にする X が 83 であれば、83 の次の数は 5 を超えてはならない
という風に分かれるので

dp[i][smaller] := X を上から i 桁目まで決めたとき、
                  それを K の上から i 桁目までと比較したときに、
    smaller = 0のとき、Kとちょうど一致する場合
    smaller = 1のとき、Kよりも小さくなっている場合

という風にしてあげます。dp[ i ][ smaller ] から dp[ i + 1 ][ smaller ] への遷移を考えるとき、
    smaller = 1 からは smaller = 1 にしか遷移せず、i 桁目は何を選んでもよいので全体の中から最適なものを選ぶ
    smaller = 0 から smaller = 0 への遷移は、K の i 桁目に忠実に合わせる (選択の余地はない)
    smaller = 0 から smaller = 1 への遷移は、K の i 桁目より小さい範囲から最適なものを選ぶ
という風にしてあげればいいです。あとは問題に応じて DP 遷移式の詳細を組み立てることになります


/* 例題
N 以下の正整数であって、十進法表記したときの各桁の数の和が D の倍数であるものの個数を mod 1,000,000,007 で求めよ。
*/

桁DPで解ける問題は
    Nが非常に大きく64bitで収まらない
    N以下の整数」について条件に合うものを数える 

N = 63435, i=2のときの一例である 63○○○ について考える, 3桁目まで決めると 
  630○○ 各桁の数の和は、9+0 で9
  631○○ 各桁の数の和は、9+1 で10
  632○○ 各桁の数の和は、9+2 で11
  633○○ 各桁の数の和は、9+3 で12
  634○○ 各桁の数の和は、9+4 で13  
「i+1桁目まで決めた時の暫定の答え」を出すためには、「i桁目までの各桁の数の和が 9」という情報が不可欠!

つまり、以下のようなDPを考える
  dp[ i ][smaller][ j ] := i 桁目までの各桁の数の和が mod Dで j となる数。ただし smaller が true ならNより小さい場合を考え、smallerが false ならNと同じ場合を考える。

基本は以下の全ての場合を考えればOK。
  dp[ i ][true] からはdp[ i+1 ][true]にのみ遷移
  dp[ i ][false] からdp[ i+1 ][true]へ遷移
  dp[ i ][false] からdp[ i+1 ][false]へ遷移
今回は dp[ i ][smaller][ j ] について考えるので、これを少し変形して、
  dp[i + 1][true] [(j + k) % D]   += dp[i][true] [j] (k = 0,1,2,…,9)
  dp[i + 1][true] [(j + k) % D]   += dp[i][false][j] (k = 0,1,2,…,𝑁𝑖)
  dp[i + 1][false][(j + 𝑁𝑖) % D]  =  dp[i][false][j]
というように更新する

最終的には
  Nが D の倍数か：dp[n][0][0]
  N以下の数がいくつ D の倍数か：dp[n][1][0]
を用いて、 dp[n][0][0]+ dp[n][1][0] – 1 が答え